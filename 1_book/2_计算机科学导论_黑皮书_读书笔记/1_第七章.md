# 计算机科学导论读书笔记
是黑皮书的计算机科学导论, 不是学校发的.

## 这个读书笔记的规范
好像还没有专门出一个文件来描述如何做读书笔记, 这里先拿这本书来做一个实验.

段落与段落之间用一个空行来进行分段, 至于前面的缩进就可以不写了.

用标签式地语言来描述一个部分里面大概讲了什么东西, 也就是概括. 标签式指的是用于定位的, 这本书里面的标题就可以当做一个标签来进行标记.

## 这本书
这个书是导论, 但是也十分地庞大和系统.
好在这本书是外国佬写的, 粗略地看下来, 从最底层到顶层都一一介绍了一番.

前面的那些章节, 实在是太底层了, 从数字开始干起, 把计算机的组成和实现全部都说了一遍, 干巴巴地. 亏他还是说用比较好懂的语言写的科普呢, 直接把我给干啥了.

不过总有一些人喜欢这个, 要是去做cpu的话, 这些东西就非看不可了. 不只是cpu, 还有操作系统的底层也不过只是一个个的数字, 要弄懂这些的话, 才能说得上有那个资格来入门……

但是我是搞应用程序的啊, 学习这些, 工作的时候都是用别人封装好的东西, 底下那些玩意都是一层又一层地抽象, 特意不给我看的. 毕竟人家也知道, 他们自己写的东西也是人家一层又一层封装好的, 如果不去把最最最开始的东西研究清楚的话, 那还不如一开始就不要去搞……

说起来, 日常用的满10进1, 还有加减乘除的这些东西, 如果用数学来描述实现原理的话, 我就看不懂了, 但是我却能将这些东西运用地十分地自然和轻松. 以此类比的话, 我日后用那些语言和技术来将一大串的逻辑描述出来, 只不过是在数学里面用高等的方法解题而已. 对于最底层, 即使不去了解也没啥必要, 因为抽象出来的东西已经建立起一个新的体系出来. 学习这个体系的话, 就学会了这一层的抽象, 而这一层的抽象又是底层的封装升级, 本身就已经实现了底层了.

不知道我说的对不对, 说不定很长时间内我都是这么认为的. 中间的过程都被整合起来, 包含在更高级的东西里面, 所以咱只用学高级的东西就可以使用了.
至于锤子怎么这么做出来的, 我不关心, 我只关心如果用这个锤子和一大堆的工具来将一个房子盖出来.

## 学习这本书
前面的章节实在是太底层了, 所以从操作系统这个部分看起.

操作系统前面是计算机网络, 里面讲了一大堆巴拉巴拉的协议的东西. 不过我想, 计算机网络的诞生很大一部分都是由于人的原因（虽然计算机本身就是因为人的需求而诞生的）, 所以不像数学那样的自然法则那样, 描述下定义什么的就搞定了. 

像中间的那些协议一样的东西, 如果大家都不遵守的话, 就没法玩了. 但是这些东西也只是人为规定的而已, 不是自然产生的. 只是无数解决方案里面最经济的一种. 

虽然讲了那么多, 但是计算机网络比操作系统还要虚渺一点, 个人感觉可以放在日后学习. 也许是因为网络通过看不见信号传播的缘故？ 个人还是先学习能在本地硬件实现的东西先把, 这个也实在一点.

但是计算机网络也是日后很重要的一部分, 想服务器后端这些东西, 如果能自己弄出来的话, 就不用拜托别人了. 这个拜托别人也包括了很多个别人……

### 第七章-操作系统
#### 目标
通过本章的学习, 可以
- 理解操作系统在计算机中的作用
- 给出操作系统的定义
- 理解把操作系统调入内存的自举过程
- 列出操作系统的组成部分
- 讨论操作系统中内存管理器的作用
- 讨论操作系统中进程管理器的作用
- 讨论操作系统中设备管理器的作用
- 讨论操作系统中文件管理器的作用
- 理解三种常见操作系统的主要特点: UNIX、Linux和Windows NT

#### 引言
##### 操作系统
这里操作系统是一个十分复杂的系统, 所以有很多的定义, 所以这里只有一些常见的定义.

这写常见的定义组合起来就是: 操作系统是计算机硬件和用户（程序和人）的一个接口, 它使得其他程序更加方便有效地运行, 并能方便地对计算机硬件和软件资源进行访问.

还提及了两个主要的设计目标:
- 有效地使用硬件
- 容易地使用资源

##### 自举过程
操作系统负责把其他程序装入内存中运行, 但是操作系统也是一个程序, 他如何将自己装入内存？

这个可以用ROM技术解决

如今使用的解决方案也有提及, 改善了很多的问题.

#### 演化
操作系统经过了很长的一段发展

##### 批处理系统
这里涉及到一个新概念: 作业

##### 分时系统
为了提高计算机资源的使用效率, 多道程序的概念被引入.

同时, 也带来了分时概念, 调度概念, 进程概念

##### 个人系统
例如DOS

##### 并行系统
装多个cpu, 进行并行处理

##### 分布式系统
需要网络

##### 实时系统
这个不是通用系统, 不在这本书的讨论范围里面.

#### 组成部分
包括内存管理器, 进程管理器, 设备管理器, 文件管理器
上面这些东西可以当做一个组织, 这些组织都归操作系统这个部门管.

但是有一个东西不属于任何部门, 但是也可以管理这些组织, 就是用户界面

##### 用户界面
涉及到命令解释程序（shell）
或者说是窗口（一个带有GUI[用户界面]的部件）

##### 内存管理器
负责内存管理, 分为两大类
- 单道程序
- 多道程序
	- 非交换
		- 分区调度
		- 分页调度
	- 交换
		 - 请求分页
		 - 请求分段

分页调度是分区调度的改进, 解决了分区调度的问题.
涉及到帧和页的概念, 程序叫页, 内存叫帧, 那里配了个图可以很直观地看明白.

请求分段常常与请求分页结合, 这样子可以结合两者之间的优点来提高效率.

虚拟内存的概念这里也提及了

##### 进程管理器
进程管理指的是有关进程的管理, 不过在了解这个之前, 要先了解一些其他的东西. 在3之后就差不多是进程管理的东西了. 至于进程管理器是干嘛的, 应该是协调程序,作业和进程这三个东西用的.
1. 程序、作业和进程的非正式定义
2. 状态图
展示了三者之间是如何转换的.
3. 调度器
有作业调度器和进程调度器
前者负责将作业变成进程或者将进程变成作业, 后者负责进程在内部各种状态之间的转换.
4. 队列
因为有很多作业, 所以需要排队. 进程管理器使用队列（等待列表）来管理.

在队列中存储的不是作业和进程本身, 而是作业或者进程控制块. 因为作业和进程本身实在是太大了, 存不进去队列里面.

这些控制块是作业和进程的代表. 作业和进程仍然保存在磁盘或者内存里面.
可以把这些控制块想象成一个id卡这样子.

一个操作系统可以有很多个队列. 这里有个图展示了作业和进程在队列里面进行的循环.

5. 进程同步
有两个概念, 死锁和饿死
书本里描述的很生动

6. 设备管理器
管理设备用的

7. 文件管理器

有些东西这里是只会讲一点点的, 因为每一个东西展开之后都十分地复杂. 这里只要了解有这么一个东西就是了.
上面的这些管理器, 后面有兴趣的话可以专门找一些书籍来研究细节.

#### 主流操作系统
介绍了unix, linux和windows这三个系统有什么特点
